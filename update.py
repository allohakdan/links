#!/usr/bin/env python
# [db] 2016/08/11
# Use with cronjob */5 * * * * ~/.../update.py
# cronjob installed on cs1
import argparse
import os
import datetime
import requests
import ConfigParser
import subprocess

# Settings - these are files in the same directory as script
configfile = "links.ini"
githubconfigurl = "https://raw.githubusercontent.com/allohakdan/links/master/links.ini"
github_edit = "https://github.com/allohakdan/links/edit/master/links.ini"
outputfile = ".htaccess"
indexfile = "links.html"

# Initialize the directory the script is located in
script_path = os.path.dirname(os.path.realpath(__file__))

class FileGenerator(object):
    """ Template buffer class for creating a file to write """
    def __init__(self, filepath):
        self.__filepath = filepath
        self.__buffer = list()
    def add(self, text):
        """ adds a line of text to be written to the file """
        self.__buffer.append(text)
    def write(self):
        """ Writes the contents of the buffer to the filepath """
        with open(self.__filepath, "w") as f:
            for line in self.__buffer:
                f.write(line+"\n")

class LinkFileGenerator(FileGenerator):
    """ The following methods are implemented by the child classes """
    def head(self):
        """ Static information to write at the top of the file """
        raise NotImplementedError()
    def tail(self):
        """ Static information to write at the bottom of the file """
        raise NotImplementedError()
    def addLink(self, name, address):
        """ Adds each link to the file """
        raise NotImplementedError()


class HtaccessGenerator(LinkFileGenerator):
    """ Writes out the htaccess file """
    def head(self):
        self.add("# This file is autogenerated - do not edit directly.")
        self.add("# Last updated: %s" % str(datetime.datetime.now()))
        self.add("Options +FollowSymLinks")
        self.add("RewriteEngine on")
        self.add("RewriteRule ^.htaccess$ - [r=404,L] # Hide links file")
        self.add("RewriteRule ^.git$ - [r=404,L] # Hide links file")
        self.add("RewriteRule ^update.py$ - [r=404,L] # Hide update scripts")
        self.add("RewriteRule ^update.sh$ - [r=404,L] # Hide update scripts")
        # self.add("RewriteRule ^links.ini$ - [r=404,L] # Hide links file")
    def addLink(self, name, address):
        self.add("RewriteRule ^%s$ %s [r=302,NE,L]" % (name, address))
    def tail(self):
        return


class IndexGenerator(LinkFileGenerator):
    """ Writes out an HTML index page """
    def head(self):
        self.add("<html><body>")
    def addLink(self, name, address):
        self.add("<a href=\"%s\">%s</a><br/>" % (address, name)) 
    def tail(self):
        self.add("</body></html>")

def compile_list(config):
    link_list = list()
    sections = config.sections()
    for section in sections:
        linkrefs = config.options(section)
        # Add links
        for linkref in linkrefs:
            name = os.path.join(section.strip('/'), linkref.strip('/'))
            address = config.get(section, linkref)
            link_list.append((name,address))
    return link_list

def compile_edit_links(config, path):
    sections = config.sections()
    link_list = list()
    with open(path) as conf_file:
        for num, line in enumerate(conf_file, 1):
            for section in sections:
                if "[%s]" % section in line:
                    name = os.path.join(section.strip(),"edit")
                    address = github_edit + "#L%d" % num
                    link_list.append((name, address))
    return link_list


if __name__ == "__main__":
    parser = argparse.ArgumentParser("update.py")
    parser.add_argument("--dont-check-update", action="store_true")
    parser.add_argument("--dont-update", action="store_true")
    parser.add_argument("--dont-pull", action="store_true")
    parser.add_argument("--path", type=str, default=script_path)

    args = parser.parse_args()

    path = args.path
    print "Using path:", path

    if not args.dont_update:
        if not args.dont_check_update:
            # Determine if the github version of the config file is different from ours 
            remote = requests.get(githubconfigurl).text
            with open(os.path.join(path,configfile), "r") as f:
                local = "".join(f.readlines())
            if remote == local:
                print "No Change"
                exit(1)
            print "Update Found"


            # Download the new changes
        if not args.dont_pull:
            process = subprocess.Popen(["git","pull","origin","master"], cwd=path, stdout=subprocess.PIPE)
            print process.communicate()[0]
    else:
        print "Skipping update"


    # Load the configuration file
    print "Loading Config file"
    if not os.path.exists(os.path.join(path,configfile)):
        raise Exception("%s files does not exist" % configfile)
    parser = ConfigParser.ConfigParser()
    parser.read(os.path.join(path,configfile))
#     if not parser.has_section("LINKS"):
#         raise Exception("LINKS section must be defined")


    # Initialize the output file buffer
    htaccess_buffer = HtaccessGenerator(os.path.join(path,outputfile))
    index_buffer = IndexGenerator(os.path.join(path,indexfile))
    htaccess_buffer.head()
    index_buffer.head()

    # Copy the links into the output file buffer
    # Why use NE - http://stackoverflow.com/a/11380893 
#     linkrefs = parser.options("LINKS")
#     for linkref in linkrefs:
#         name = linkref
#         address = parser.get("LINKS", linkref)
#         htaccess_buffer.addLink(name, address)
#         index_buffer.addLink(name, address)
    link_list = compile_list(parser)
    edit_links = compile_edit_links(parser, os.path.join(path,configfile))
    for name, address in link_list:
        htaccess_buffer.addLink(name, address)
        index_buffer.addLink(name, address)
    for name, address in edit_links:
        print "Adding %s  = %s" % (name, address)
        htaccess_buffer.addLink(name, address)
        index_buffer.addLink(name, address)




    htaccess_buffer.tail()
    index_buffer.tail()

    # Write the buffer to the output file
    htaccess_buffer.write()
    index_buffer.write()

